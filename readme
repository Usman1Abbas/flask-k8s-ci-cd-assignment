 ğŸš€ Flask Kubernetes CI/CD Pipeline

### **Cloud MLOps â€“ Assignment #3**

This repository implements a complete **End-to-End CI/CD pipeline** for a Python **Flask application**, using:

* **GitHub + GitHub Actions** for Continuous Integration
* **Jenkins** for Continuous Delivery
* **Docker** for containerization
* **Kubernetes (Minikube)** for orchestration
* **Protected main branch + PR workflow**
* **Rolling updates, scaling, and load balancing**

---

## ğŸ‘¥ Team Members

| Name       | Role          | Responsibilities                                                              |
| ---------- | ------------- | ----------------------------------------------------------------------------- |
| **Usman**  | **Admin**     | Repo setup, branch protection, PR reviews, Minikube + Jenkins setup           |
| **Ahmad**  | **Developer** | Flask app, Dockerfile, GitHub Actions workflow, Kubernetes YAMLs, Jenkinsfile |
| **Shazil** | **Tester**    | Unit tests, linting, CI validation, Kubernetes scaling & rollout testing      |

---

## ğŸ“Œ Project Features

### âœ” Flask Application

A simple Flask API returning: **â€œHello, World!â€**

### âœ” Continuous Integration (GitHub Actions)

Runs automatically on every push:

* Python setup
* Install dependencies
* **flake8** (max line length = 90)
* **pytest** unit tests
* Docker image build

### âœ” Continuous Delivery (Jenkins â†’ Kubernetes)

Triggered on merges into **main**:

1. Build Docker image
2. Deploy to Kubernetes
3. Verify rollout, pods, and services

### âœ” Kubernetes (Minikube)

* Rolling updates (maxSurge / maxUnavailable)
* Multi-replica Deployment
* Resource limits & requests
* NodePort Service (load balancing)
* Scaling & rollback supported

---

## ğŸ“ Repository Structure

```
flask-k8s-ci-cd-assignment/
â”‚â”€â”€ app.py
â”‚â”€â”€ requirements.txt
â”‚â”€â”€ Dockerfile
â”‚â”€â”€ Jenkinsfile
â”‚â”€â”€ README.md
â”‚â”€â”€ .github/
â”‚     â””â”€â”€ workflows/
â”‚           â””â”€â”€ ci.yml
â”‚â”€â”€ kubernetes/
â”‚     â”œâ”€â”€ deployment.yaml
â”‚     â””â”€â”€ service.yaml
â”‚â”€â”€ tests/
â”‚     â”œâ”€â”€ sample.py
â”‚     â””â”€â”€ test_sample.py
```

---

## ğŸ Running the App Locally with Docker

### 1ï¸âƒ£ Build the Docker Image

```bash
docker build -t flask-app .
```

### 2ï¸âƒ£ Run the Container

```bash
docker run -p 5000:5000 flask-app
```

Visit in browser:

```
http://localhost:5000
```

---

## â˜¸ï¸ Kubernetes Deployment (Manual on Minikube)

### Start Minikube

```bash
minikube start
```

### Apply All Manifests

```bash
kubectl apply -f kubernetes/
```

### Check Resources

```bash
kubectl get pods
kubectl get deployments
kubectl get services
```

### Access Service

```bash
minikube service flask-service
```

---

## ğŸ”„ CI/CD Workflow Summary

### **1ï¸âƒ£ GitHub Actions â€“ Continuous Integration**

Checks on every push:

* Linting
* Unit tests
* Docker build

### **2ï¸âƒ£ Jenkins â€“ Continuous Delivery**

Triggered when merging into **main**:

1. Build the Docker image
2. Deploy to Kubernetes
3. Validate rollout/pods/services

---

## â˜¸ï¸ Kubernetes Features Implemented

### âœ” Rolling Updates

Uses Kubernetes Deployment strategy:

* `maxSurge`
* `maxUnavailable`

### âœ” Horizontal Scaling

```bash
kubectl scale deployment flask-deployment --replicas=4
```

### âœ” Rollback

```bash
kubectl rollout undo deployment/flask-deployment
```

### âœ” Load Balancing

Provided via `NodePort` service across replicas.

### âœ” Resource Limits

Ensures stable workload scheduling.

---

## ğŸ›  Team Workflow Summary

### **Admin â€“ Usman**

* Created repo
* Branch protection
* Milestones & issues
* Minikube + Jenkins setup
* PR review & merging

### **Developer â€“ Ahmad**

* Wrote Flask app
* Dockerfile
* GitHub Actions CI
* Kubernetes manifests
* Jenkinsfile pipeline

### **Tester â€“ Shazil**

* pytest test suite
* flake8 configuration
* GitHub Actions validation
* Kubernetes rollout & scaling tests

---

## ğŸ“¦ End-to-End Automation Summary

1. Developer pushes code â†’ **GitHub Actions CI runs**
2. Tester validates â†’ Admin reviews PR
3. PR merged into **develop**, then into **main**
4. Jenkins job triggers
5. Jenkins builds & deploys to Minikube
6. Kubernetes applies rolling update
7. App accessible via LoadBalancer / NodePort

âœ” Fully automated CI/CD
âœ” Verified by Admin, Developer, and Tester

